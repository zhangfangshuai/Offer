#### 从输入URL到页面页面呈现的过程

### 全过程发生了什么

1.浏览器接受URL开启网络请求线程（涉及到：浏览器机制，线程与进程等）
2.开启网络线程到发出一个完整的http请求（涉及到：DNS解析，TCP/IP请求，5层网络协议等）
3.从服务器接收到请求到对应后台接受到请求（涉及到：负载均衡，安全拦截，后台内部处理等）
4.后台与前台的http交互（涉及到：http头，响应码，报文结构，cookie等）
5.缓存问题（涉及到：http强缓存与协商缓存等）
6.浏览器接受到http数据包后的解析流程（涉及到html词法分析，解析成DOM树，解析CSS生成CSSOM树，合并生成render渲染树。然后layout布局，painting渲染，复合图层合成，GPU绘制，等）

&emsp;

### 地址栏输入URL
当我们在浏览器地址栏输入URL地址后，浏览器会开一个线程来对我们输入的URL进行解析处理。

浏览器中的各个进程及作用：（多进程）

- **浏览器进程：**负责管理标签页的创建销毁以及页面的显示，资源下载等。
- **第三方插件进程：**负责管理第三方插件。
- **GPU进程：**负责3D绘制与硬件加速（最多一个）。
- **渲染进程：**负责页面文档解析（HTML，CSS，JS），执行与渲染。（可以有多个）


&emsp;

### DNS域名解析

##### 1、为什么需要DNS域名解析？
因为我们在浏览器中输入的URL通常是一个域名，并不会直接去输入IP地址（纯粹因为域名比IP好记），但我们的计算机并不认识域名，它只知道IP，所以就需要这一步操作将域名解析成IP。

&emsp;

##### 2、URL组成部分
URL的各个组成部分被存储在`window.location`中，也可通过它拿到各个值，全值在`window.location.href`上
- **protocol：**协议头，比如http，https，ftp等；
- **host：**主机域名或者IP地址；
- **port：**端口号；
- **path：**目录路径；
- **query：**查询的参数；
- **hash：**#后边的hash值，用来定位某一个位置。

&emsp;

##### 3、解析过程

```plantuml
浏览器 -> 计算机本地: 没有DNS缓存，去计算机本地查找
计算机本地 -> 网络提供商: 没有缓存，去递归式DNS服务器查找
网络提供商 -> 权威DNS服务器: 没有缓存，通过根域名和TLD域名服务器，到权威DNS服务器查找
权威DNS服务器 -> 网络提供商: 找到，返回并缓存到递归式DNS服务器
网络提供商 -> 计算机本地: 返回DNS，并缓存到本地
计算机本地 -> 浏览器: 返回DNS，并缓存到浏览器
```

?>DNS解析是非常耗时的，如果页面中需要解析的域名过多，是非常影响页面性能的。考虑使用DNS预加载或减少DNS解析进行优化。


&emsp;

### 发送HTTP请求(TCP/IP)

拿到了IP地址后，就可以发起HTTP请求了。HTTP请求的本质就是TCP/IP的请求构建。<br>
建立连接时需要 **「3次握手」** 进行验证，断开链接也同样需要 **「4次挥手」** 进行验证，保证传输的可靠性。

![TCP](https://img-blog.csdnimg.cn/4e6c73625adf4344bdc100cc177241ce.png)


##### 1、三次握手

【**字段说明**】
- **SYN：**（synchronize：使同步）标志位，值为`1`表示要建连;
- **seq：**序列号，随机生成;
- **ACK：**验证字段，值为对方序列号`+1`;

【**详细过程**】
1. **第一次握手：客户端发起带有SYN=1的数据包给服务端** <br>
客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；

2. **第二次握手：服务端接收到，回复一个带有SYN/ACK数据包给客户端，确认收到** <br>
服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；

3. **第三次握手：客户端接收到，回复SYN/ACK数据包给服务端，确认收到。建连成功！** <br>
客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。

&emsp;

##### 2、TCP通信

TCP通信是全双工模式，建立连接成功后，双方就可以互相、同时发送和接收消息。

连接完成后，发起方数据包只包含 `seq` 和 `ACK`，回复方数据包只包含 `ACK`，值为发起方`seq + 1`.

&emsp;

##### 3、四次挥手

【**字段说明**】
- **FIN：**（Finish）标志位，值为`1`表示要断开连接;
  
【**详细过程**】
1. **客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态** <br>
客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；

2. **服务端收到FIN后，发送一个ACK给客户端，服务端进入CLOSE_WAIT状态；** <br>
客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；

3. **服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态** <br>
客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；

4. **客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给服务端，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手** <br>
客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）
至此TCP断开的4次挥手过程完毕



&emsp;

### 数据传输(五层网络协议)

第五层：**应用层（DNS，HTTP）：**DNS解析成IP并发送http请求；<br>
第四层：**传输层（TCP，UDP）：**建立TCP连接（3次握手）；<br>
第三层：**网络层（IP，ARP）：**IP寻址；<br>
第二层：**数据链路层（PPP）：**封装成帧；<br>
第一层：**物理层（利用物理介质传输比特流）：**物理传输（通过双绞线，电磁波等各种介质）。

?> **OSI七层协议**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层


&emsp;

### 服务器接收与响应

HTTP 请求到达服务器，服务器进行对应的处理。 最后要把数据传给浏览器，也就是返回网络响应。<br>
跟请求部分类似，网络响应具有三个部分： 响应行、响应头和响应体。

##### 1、状态码（HTTP Code）
状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值:

- **1xx：**指示信息–表示请求已接收，继续处理。
- **2xx：**成功–表示请求已被成功接收、理解、接受。
- **3xx：**重定向–要完成请求必须进行更进一步的操作。
- **4xx：**客户端错误–请求有语法错误或请求无法实现。
- **5xx：**服务器端错误–服务器未能实现合法的请求。

比较常见的状态码有：<br>
`200` <br>
`204`（No Content，无内容，不刷新不跳转）, <br>
`206`（已处理部分请求），<br>
`301`（永久重定向）, <br>
`302`（临时重定向）, <br>
`304`（未修改，使用缓存）, <br>
`400` <br>
`401`（无权限）, <br>
`403`（禁止访问文件）, <br>
`404`（资源不存在）, <br>
`422`（语义错误无法处理）, <br>
`500`

&emsp;

##### 2、返回相应文件
请求响应成功后，返回HTTP Code 200，服务器会返回相应的网页，浏览器接收到响应成功的报文后便开始下载网页，至此，本次网络通信结束。

&emsp;

##### 3、响应完成之后怎么办？TCP连接就断开了吗？
不一定。<br>
这时候要判断 `Connection` 字段, 如果请求头或响应头中包含 `Connection: Keep-Alive`， 表示建立了持久连接，这样TCP连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开TCP连接, 请求-响应流程结束。

&emsp;


### 浏览器解析渲染页面

一个网页会找服务器下载多个资源，在接收到HTML，CSS，JS等首页所需文件之后，浏览器开始执行解析与渲染

![render过程](https://img-blog.csdnimg.cn/17c66b4ded0e40c38e993bca7cf129e1.png)

##### 1、解析HTML构建 `DOM Tree`
浏览器拿到服务器返回的网页之后，首先会根据顶部定义的`DTD`类型进行对应的解析，解析过程将被交给内部的GUI渲染线程来处理。

!> DTD（Document Type Definition）文档类型定义

常见的有：
```
// HTML5文档定义
<!DOCTYPE html>
// 用于XHTML 4.0 的严格型 
<!DOCTYPE HTMLPUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"> 
// 用于XHTML 4.0 的过渡型 
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> 
// 用于XHTML 1.0 的严格型 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"> 
// 用于XHTML 1.0 的过渡型
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
```

**HTML解释器**的工作就是将网络或者本地磁盘获取的HTML网页或资源从字节流解释成DOM树结构:

?>字节流(Bytes) --> 字符流(Characters) --> 词语(Tokens) --> 节点1/节点2...   -> DOM Tree

- 这个过程中，如果遇到的节点是 JS 代码，就会调用 JS引擎 对 JS代码进行解释执行，此时由于 **JS引擎 和 GUI渲染线程** 的互斥，GUI渲染线程 就会被挂起，渲染过程停止，如果 JS 代码的运行中对DOM树进行了修改，那么DOM的构建需要重新开始
- 如果节点需要依赖其他资源，图片/CSS等等，就会调用网络模块的资源加载器来加载它们，它们是异步的，不会阻塞当前DOM树的构建
- 如果遇到的是 JS 资源URL（没有标记异步），则需要停止当前DOM的构建，直到 JS 的资源加载并被 JS引擎 执行后才继续构建DOM

&emsp;

##### 2、解析CSS构建CSSOM Tree
CSS解释器会将CSS文件解释成内部表示结构，生成CSS规则树，这个过程也是和DOM解析类似的，CSS 字节转换成字符，接着词法解析与法解析，最后构成 CSS对象模型(CSSOM) 的树结构

&emsp;

##### 3、构建渲染树（Render Tree）
等DOM Tree与CSSOM Tree都构建完毕后，接着将它们合并成**渲染树（Render Tree）**，渲染树 只包含渲染网页所需的节点，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。

&emsp;

##### 5、渲染（布局，绘制，合成）
这个过程包括：
1. 计算CSS样式；
2. 构建渲染树；
3. 布局，主要定位坐标和大小，是否换行，各种`position overflow z-index`属性 ；
4. 绘制，将图像绘制出来。

此时涉及到两个概念：**回流（reflow）与 重绘（repaint）**

（1）Reflow：即回流。一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。<br>
（2）Repaint：即重绘。意味着元素发生的改变只是影响了元素的一些外观之类的时候（例如，背景色，边框颜色，文字颜色等），此时只需要应用新样式绘制这个元素就可以了。

回流的成本开销要高于重绘，而且一个节点的回流往往回导致子节点以及同级节点的回流， 所以优化方案中一般都包括，尽量避免回流。

!> 回流一定导致重绘，但重绘不一定会导致回流

**合成（composite）**，浏览器会将各层信息发送给GPU，GPU将各层合成，显示在屏幕上

&emsp;

##### 6、普通图层和复合图层

可以简单的这样理解，浏览器渲染的图层一般包含两大类：普通图层以及复合图层<br>

首先，普通文档流内可以理解为一个复合图层（这里称为默认复合层，里面不管添加多少元素，其实都是在同一个复合图层中）<br>
其次，`absolute`布局（`fixed`也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。<br>
然后，可以通过硬件加速的方式，声明一个新的复合图层，它会单独分配资源 （当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响默认复合层里的回流重绘）<br>

可以简单理解下：**GPU中，各个复合图层是单独绘制的，所以互不影响**，这也是为什么某些场景硬件加速效果一级棒<br>

?>可以`Chrome源码调试 -> More Tools -> Rendering -> Layer borders`中看到，黄色的就是复合图层信息。

