#### JS的事件循环机制

### 为什么JS是单线程

&emsp; Javascript的主要用户是用户交互及操作DOM，这决定了它必须是单线程的，原因就是避免多线程复杂的同步问题。假设JS有两个线程，其中一个在某个DOM节点上添加内容，另一个在删除这个节点，此时浏览器应该以哪个线程为准就无法判定。

虽然在H5 web worker标准中允许创建多线程，但子线程完全受主线程控制且不得操作DOM，这并未改变单线程的本质。

<br>

### 为什么需要异步任务？

&emsp; 由于JS是单线程的原因，所有待执行的任务就需要排队，前一个任务结束，才执行下一个任务。如果前一个任务耗时严重，后一个任务就不得不一直等着。

在早期ajax出现之前，请求发出后需要等待响应才能继续后续任务，也就是说因为IO设备处理速度缓慢导致大量的cpu资源浪费。如果主线程完全不等待IO设备，挂起处于等待中的任务，先运行排在后面的任务，等到IO设备返回了结果，再来处理挂起的任务，就可以解决这个等待问题。异步任务因此而来。

<br>

### 任务队列

&emsp; 任务队列，有些地方也称作“回调队列”，是用来存放被主进程挂起事件的容器。在数据结构上，是满足先进先出的队列结构。

任务分两种：同步任务 和 异步任务

- **同步任务**：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- **异步任务**：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

**在执行任务解析时，如果是同步任务，会直接进入主线程；如果是异步任务，会进入到任务队列**

&emsp; "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，如果存在"定时器"异步任务，主线程首先要检查一下执行时间，这些事件只有到了规定的时间，才能返回主线程。

<br>

### 宏任务与微任务

##### 1. 宏任务（MacroTask）
一个 **宏任务（或任务）** 就是由执行诸如从头执行一段程序、执行一个事件回调或一个 `interval/timeout` 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 任务队列（task queue）上被调度。有三个时机会触发宏任务被调度。<br>
（1）一段新程序或子程序被直接执行时（比如从一个控制台，或在一个script元素中运行代码）。<br>
（2）触发了一个事件，将其回调函数添加到任务队列时。<br>
（3）执行到一个由 `setTimeout()` 或`setInterval()` 创建的 timeout 或 interval，以致相应的回调函数被添加到任务队列时。

&emsp; 事件循环驱动你的代码按照这些任务排队的顺序，一个接一个地处理它们。在当前迭代轮次中，只有那些当事件循环过程开始时 已经处于任务队列中 的任务会被执行。其余的任务会等待到下一次迭代。

**常见的宏任务种类**：<br>
`script全部代码如 main`、`setTimeout`、`setInterval`、`setImmediate(Node)`、`I/O操作`、 `UI Rendering`

##### 2. 微任务（MicroTask）
&emsp; 微任务和任务之间的差异看起来不大，都由位于某个队列的 JavaScript 代码组成并在合适的时候运行。但是，对于宏任务，只有在迭代开始时队列中存在的宏任务才会被事件循环一个接一个地运行，这和处理微任务队列殊为不同。<br>
&emsp; 首先，每当一个宏任务存在，事件循环都会检查该宏任务是否正把控制权交给其他 JavaScript 代码。如若不然，**事件循环**就会运行**微任务队列 Micro queue**中的所有微任务。接下来**微任务循环**会在事件循环的每次迭代中被处理多次，包括处理完事件和其他回调之后。<br>
&emsp; 其次，如果一个微任务通过调用 `queueMicrotask()`, 向队列中加入了更多的微任务，则那些新加入的微任务会早于下一个宏任务运行。这是因为事件循环会持续调用微任务直至队列中没有留存的，即使是在有更多微任务持续被加入的情况下。

**常见的微任务** <br>

`Process.nextTick(Node)`、`Promise`（典型的微任务）、`Object.observe`(废弃)、`MutationObserver`

?> 微任务不是单条语句，他在事件循环机制中也有一个队列，叫MicroTask queue，在当前宏任务执行结束前，由微任务循环来读取 



<br>

### 异步任务的运行机制
（1）所有同步任务都在主线程上排队执行，形成一个**执行栈** <br>
（2）主线程之外，还存在一个"任务队列"。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。<br>
（3）一旦"执行栈"中的所有同步任务执行完毕，也就是说主进程得空了，就会去读取"任务队列"里那些异步任务，结束等待状态，进入执行栈开始执行。 <br>
（4）主线程不断重复上诉第(3)步


![任务执行过程](https://img-blog.csdnimg.cn/5b869743f3d844f9bf621d78ba9d859e.gif) <br>
<small style="color: #909399">【注】图片来自网络，侵删</small>

&emsp; 可以看到，异步任务是一个一个进入执行栈，而不是一次读取全部。如果异步任务执行过程中来了新的同步任务，会排在当前异步任务内部的所有同步任务之后，内部异步任务之前（如有）。当然也会在任务队列里下一个异步任务之前执行。

<br>

### Event Loop

![同步与异步](https://img-blog.csdnimg.cn/e0db427ca69e48e09d994c91a858214a.png)

<br>

### 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，`setTimeout()`和`setInterval()`。它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

```javascript
console.log(1);
setTimeout(function(){console.log(2);},0);
console.log(3);

// 1, 3, 2
```
这段代码很简单，其原理是解析器在解析代码时，按着程序执行顺序，把同步任务第一行和第三行放入执行栈，第二行定时器放入任务队列等待执行。

`setTimeout(fn,0)`的含义是，指定某个任务在主线程最早可得的空闲时间执行，他会被追加到当前任务队列的尾部。对于设定了第二个参数延时时长的定时器，通常情况下会等到延时到期时执行，但也有例外，如果执行栈中的同步任务有比较耗时的操作，有可能要等很久，那么任务队列里的定时器就必须等到该同步任务执行完才可能被主线程读取进入执行栈，也就是说，执行时机可能会超过设定的延时时长。

<br>

### NodeJs的异步事件

除了`setTimeout`和`setInterval`这两个方法，Node.js还提供了另外两个与"任务队列"有关的方法：`process.nextTick` 和 `setImmediate`

- **process.nextTick**方法可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。

```js
process.nextTick(function A() {
  console.log(1);
  process.nextTick(function B(){console.log(2);});
});
```

- **setImmediate**方法则是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与`setTimeout(fn, 0)`很像。

```js
setImmediate(function A() {
  console.log(1);
  setImmediate(function B(){console.log(2);});
});
```

##### 这两者的主要区别

`process.nextTick`指定的回调函数是在本次"事件循环"触发，而`setImmediate`指定的是在下次"事件循环"触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查"任务队列"）。


