#### JS的事件循环机制

想理解更深刻，建议提前阅读[线程、进程、浏览器内核](/JS/browserCore)一文

### 为什么JS是单线程

&emsp; Javascript的主要功能是用户交互及操作DOM，这决定了它必须是单线程的，原因就是避免多线程复杂的同步问题。假设JS有两个线程，其中一个在某个DOM节点上添加内容，另一个在删除这个节点，此时浏览器应该以哪个线程为准就无法判定。

虽然在H5 web worker标准中允许创建多线程，但子线程完全受主线程控制且不得操作DOM，这并未改变单线程的本质。

<br>

### 为什么需要异步任务？

&emsp; 由于JS是单线程的原因，所有待执行的任务就需要排队，前一个任务结束，才执行下一个任务。如果前一个任务耗时严重，后一个任务就不得不一直等着。

在早期ajax出现之前，请求发出后需要等待响应才能继续后续任务，也就是说因为IO设备处理速度缓慢导致大量的cpu资源浪费。如果主线程完全不等待IO设备，挂起处于等待中的任务，先运行排在后面的任务，等到IO设备返回了结果，再来处理挂起的任务，就可以解决这个等待问题。异步任务因此而来。

<br>

### 任务队列

&emsp; 任务队列，有些地方也称作“回调队列”，是用来存放被主进程挂起事件的容器。在数据结构上，是满足先进先出的队列结构。

JS任务分两种：同步任务 和 异步任务

- **同步任务**：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
- **异步任务**：不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

**在执行任务解析时，如果是同步任务，会直接进入主线程，如setTimeout函数自身；如果是异步任务，会进入到任务队列，如setTimeout的回调函数**

&emsp; "任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就会被系统读取进入执行栈。如果是定时器的异步任务，需要等到指定时间到期才会被加入到任务队列中，其中，定时器的计时工作并不是JS引擎线程做的，而是由浏览器内核（即渲染进程）的定时触发器线程执行。

<br>

### 宏任务与微任务

##### 1. 宏任务（MacroTask）
&emsp; 一个 **宏任务（或任务）** 如main入口、一个事件回调或一个 `interval/timeout` 被触发之类的标准机制而被调度的任意 JavaScript 代码。这些都在 任务队列（task queue）上被调度。有三个时机会添加宏任务。<br>
（1）一段新程序或子程序被直接执行时<br>
（2）触发了HTTP请求，将其回调函数添加到任务队列时<br>
（3）执行到 `setTimeout()` 或`setInterval()` ，以致它们的回调函数被添加到任务队列时。

&emsp; 事件循环驱动你的代码按照这些任务排队的顺序，从任务队列有序的处理它们。只有那些已经处于任务队列中的任务会被依次调度。其余的任务会等待到下一次迭代检查，如定时器任务未到期，它的回调不会被添加到任务队列中。

**常见的宏任务种类**：<br>
`JS执行入口`、`setTimeout`、`setInterval`、`requestAnimationFrame`、`setImmediate(Node)`、`I/O操作`、 `UI Rendering`

##### 2. 微任务（MicroTask）
&emsp; 与宏任务不同的是，微任务对资源是<span class="red-code">抢占式</span>的，一旦有微任务被添加到任务队列，进入**微任务队列 Micro queue**中，它会在本轮次事件循环结束前，被调度进入执行栈中执行，当该微任务执行完成，系统再次检查任务队列是否还有其他微任务，直到当前所有微任务执行完毕，结束本轮次事件循环，开始下一个事件循环读取下一个宏任务。<br>
&emsp; JS允许我们通过调用 `queueMicrotask()`手动的向队列中加入微任务。

值得注意的是，浏览器CPU在调度两个宏任务之间会有一次GUI线程的渲染，微任务是早于本次GUI渲染的。

**常见的微任务** <br>

`Process.nextTick(Node)`、`Promise`（典型的微任务）、`MutationObserver`（监视DOM树是否被更改，执行回调）

?> 微任务不是单条语句，他在事件循环机制中也有一个队列，叫MicroTask queue，在当前宏任务执行结束前，由微任务循环来读取 



<br>

### 异步任务的运行机制
（1）所有同步任务都在执行栈上排队，由JS引擎线程（本文也称主线程）挨个执行 <br>
（2）JS引擎线程之外，还存在一个"任务队列"。只要异步任务满足了触发回调函数的条件，就会把回调函数添加到"任务队列"中<br>
（3）"执行栈"中的所有同步任务执行完毕，系统读取"任务队列"里排队第一的任务，进入执行栈开始执行。 <br>
（4）事件循环以上三步


![任务执行过程](https://img-blog.csdnimg.cn/5b869743f3d844f9bf621d78ba9d859e.gif) <br>
<small style="color: #909399">【注】图片来自网络，侵删</small>

&emsp; 可以看到，异步任务是一个一个进入执行栈，而不是一次读取全部。如果异步任务执行过程中来了新的同步任务，会排在当前异步任务内部的所有同步任务之后，内部异步任务之前（如有）。当然也会在任务队列里下一个异步任务之前执行。

<br>

### Event Loop

![同步与异步](https://img-blog.csdnimg.cn/e0db427ca69e48e09d994c91a858214a.png)

<br>

### 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，`setTimeout()`和`setInterval()`。它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。

```javascript
console.log(1);
setTimeout(function(){console.log(2);},0);
console.log(3);

// 1, 3, 2
```
这段代码很简单，其原理是解析器在解析代码时，按着程序执行顺序，把同步任务第一行和第三行放入执行栈，第二行定时器放入任务队列等待执行。

`setTimeout(fn,0)`的含义是，指定某个任务在主线程最早可得的空闲时间执行，他会被追加到当前任务队列的尾部。对于设定了第二个参数延时时长的定时器，通常情况下会等到延时到期时执行，但也有例外，如果执行栈中的同步任务有比较耗时的操作，有可能要等很久，那么任务队列里的定时器就必须等到该同步任务执行完才可能被主线程读取进入执行栈，也就是说，执行时机可能会超过设定的延时时长。

<br>

### NodeJs的异步事件

除了`setTimeout`和`setInterval`这两个方法，Node.js还提供了另外两个与"任务队列"有关的方法：`process.nextTick` 和 `setImmediate`

- **process.nextTick**方法可以在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。也就是说，它指定的任务总是发生在所有异步任务之前。

```js
process.nextTick(function A() {
  console.log(1);
  process.nextTick(function B(){console.log(2);});
});
```

- **setImmediate**方法则是在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与`setTimeout(fn, 0)`很像。

```js
setImmediate(function A() {
  console.log(1);
  setImmediate(function B(){console.log(2);});
});
```

##### 这两者的主要区别

`process.nextTick`指定的回调函数是在本次"事件循环"触发，而`setImmediate`指定的是在下次"事件循环"触发，所以很显然，前者总是比后者发生得早，而且执行效率也高（因为不用检查"任务队列"）。


