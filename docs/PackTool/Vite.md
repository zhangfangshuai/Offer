#### vite比webpack好在哪
&emsp; **webpack：** 分析依赖=> 编译打包=> 交给本地服务器进行渲染。首先分析各个模块之间的依赖，然后进行打包，在启动webpack-dev-server，请求服务器时，直接显示打包结果。webpack打包之后存在的问题：随着模块的增多，会造成打出的 bundle 体积过大，进而会造成热更新速度明显拖慢

![webpack](https://img-blog.csdnimg.cn/20210417225533423.png)

&emsp; **vite：** 启动服务器=> 请求模块时按需动态编译显示。是先启动开发服务器，请求某个模块时再对该模块进行实时编译，因为现代游览器本身支持ES-Module，所以会自动向依赖的Module发出请求。所以vite就将开发环境下的模块文件作为浏览器的执行文件，而不是像webpack进行打包后交给本地服务器。

![vite](https://img-blog.csdnimg.cn/20210417225611243.png)

?>&emsp; 分析了过程可以发现，vite比webpack打包快的原因是：它在启动的时候不需要打包，所以不用分析模块与模块之间的依赖关系，不用进行编译。当浏览器请求某个模块时，vite根据需要对模块内容进行编译（按需加载）。按需动态编译可以缩减编译时间，当项目越复杂，模块越多的情况下，vite优势越明显于webpack。
#### 1、优化了缓慢的服务器启动

&emsp; 使用 JS 开发的打包工具如webpack、rollup、parcel通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率。<br>
&emsp; 当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器启动时间。<br>
（1）对于依赖这部分纯JS代码，Vite 使用`esbuild`预构建依赖，这部分可以比普通打包器快出几十倍效率。<br>
（2）对于源码，即代码中使用JSX，CSS或虚拟DOM这些代码文件，Vite 以 原生 ESM 方式提供，这实际上是让浏览器接管了打包程序的部分工作；Vite 只需要在浏览器请求源码时进行转换并按需提供源码，动态导入代码，即只在当前屏幕上实际使用时才会被处理。因此节约了资源。


#### 2、优化了更新速度

基于打包器启动时，重建整个包的效率很低。原因显而易见：因为这样更新速度会随着应用体积增长而直线下降。

<br>

### TODO

更新中...
